#' Length check
#' Internal length check used by \code{\link{testModuleScore}}
#'
#' @author Tito Candelli
#' @keywords internal

LengthCheck <- function(values, cutoff=0){
  return(vapply(X = values, FUN = function(x) {
    return(length(x = x) > cutoff)
  }, FUN.VALUE = logical(1)))
}

#' Calculate module score from a list of genes
#'
#' This is an identical method to that implemented in Seurat by \code{\link[Seurat]{AddModuleScore}}, but with the ability to ensure that the control genes per query gene are unique
#'
#' @param expMatrix Normalized count matrix, can be generated by calling \code{\link[Seurat]{GetAssayData}}
#' @param genes.list List of genes to query for module score (default: NULL)
#' @param genes.pool Genes from which control genes can be pulled from (not used by default, therefore all genes are fair game)
#' @param n.bin Number of average expression bins to divide the data over (default: 25)
#' @param seed.use Seed (default: 1)
#' @param ctrl.size Number of control genes per query gene (default: 100)
#' @param enrich.name Name of output module score(s) (default: "Cluster")
#' @param uniqueOnly Should control genes lists be unique? (default: TRUE)
#'
#' @return Dataframe containing calculated module score(s)
#' @export
#' @author Tito Candelli
#'
#' @examples
#' \dontrun{
#' paneth.genes <- c("DEFA6","PLA2G2A","PRSS2","REG3A","ITLN2","defa5-ires2-dsred")
#' paneth.score <- testModuleScore(Seurat::GetAssayData(srat),
#'                                 genes.list = list(paneth.genes), uniqueOnly = F, ctrl.size = 100)}

testModuleScore <- function (expMatrix, genes.list = NULL, genes.pool = NULL, n.bin = 25,
                             seed.use = 1, ctrl.size = 100, enrich.name = "Cluster", uniqueOnly=T)
{
  genes.old <- genes.list
  if (0) {
    1==1
  }
  else {
    if (is.null(x = genes.list)) {
      stop("Missing input gene list")
    }
    genes.list <- lapply(X = genes.list, FUN = function(x) {
      return(intersect(x = x, y = rownames(x = expMatrix)))
    })
    cluster.length <- length(x = genes.list)
  }
  if (!all(LengthCheck(values = genes.list))) {
    warning(paste("Could not find enough genes in the object from the following gene lists:",
                  paste(names(x = which(x = !LengthCheck(values = genes.list)))),
                  "Attempting to match case..."))
    genes.list <- lapply(X = genes.old, FUN = CaseMatch,
                         match = rownames(x = expMatrix))
  }
  if (!all(LengthCheck(values = genes.list))) {
    stop(paste("The following gene lists do not have enough genes present in the object:",
               paste(names(x = which(x = !LengthCheck(values = genes.list)))),
               "exiting..."))
  }
  if (is.null(x = genes.pool)) {
    genes.pool = rownames(x = expMatrix)
  }
  data.avg <- apply(X = expMatrix[genes.pool, ], MARGIN = 1,
                    FUN = mean)
  data.avg <- data.avg[order(data.avg)]
  data.cut <- as.numeric(x = Hmisc::cut2(x = data.avg, m = round(x = length(x = data.avg)/n.bin)))
  names(x = data.cut) <- names(x = data.avg)
  ctrl.use <- vector("list", cluster.length)
  for (i in 1:cluster.length) {
    genes.use <- genes.list[[i]]
    for (j in 1:length(x = genes.use)) {
      ctrl.use[[i]] <- c(ctrl.use[[i]], names(x = sample(x = data.cut[which(x = data.cut ==
                                                                              data.cut[genes.use[j]])], size = ctrl.size, replace = FALSE)))
    }
  }
  if (uniqueOnly){
    ctrl.use <- lapply(X = ctrl.use, FUN = unique)
  }

  ctrl.scores <- c()
  for (i in 1:length(ctrl.use)) {
    genes.use <- ctrl.use[[i]]
    ctrl.scores <- rbind(ctrl.scores, apply(X = expMatrix[genes.use,
    ], MARGIN = 2, FUN = mean))
  }
  genes.scores <- c()
  for (i in 1:cluster.length) {
    genes.use <- genes.list[[i]]
    genes.scores <- rbind(genes.scores, apply(X = expMatrix[genes.use,
    ], MARGIN = 2, FUN = mean))
  }
  genes.scores.use <- genes.scores - ctrl.scores
  rownames(x = genes.scores.use) <- paste0(enrich.name, 1:cluster.length)
  genes.scores.use <- t(x = as.data.frame(x = genes.scores.use))
  return(genes.scores.use)
}
