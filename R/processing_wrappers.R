#' Preprocess incoming raw data
#'
#' This function runs the first pre-processing steps on the raw count data
#' stored in \code{\link{raw_data}}
#'
#'
#' @param data_list Raw count data stored in
#'   \code{\link{raw_data}}
#'
#' @details
#'   This function runs the following pre-processing steps on the input raw
#'   count data: \enumerate{ \item Gives cells from each condition unique names
#'   so the count tables can be merged \item Compiles useful metadata fields
#'   from the count tables, including: \itemize{\item Mitochondrial read
#'   percentage \item Log2 transcript counts \item Log2 feature counts \item
#'   Culture condition} \item Merges count matrices and metadata tables and
#'   filters mitochondrial genes and \code{\link{stressed_cells}} \item Creates
#'   the Seurat object (filtering features expressed in fewer than 3 cells) and
#'   filters cells with \itemize{\item Fewer than 3000 transcripts \item More
#'   than 60000 transcripts \item Mitochondrial transcript percentage greater
#'   than 25\\% }}
#'
#' @return A filtered Seurat object which is ready for integration using \code{\link{integrate_data}}
#' @export
#' @family data processing
#'
#' @examples
#' \dontrun{
#' preprocess_data()}
preprocess_data <- function(data_list=PanethAnalysis::raw_data){

  message("Reading data...")

  # Give cells unique names so they can be merged
  for (table in seq_along(PanethAnalysis::raw_data)){
    colnames(data_list[[table]]) <- paste0(colnames(data_list[[table]]),"_",gsub(".*_","",names(data_list)[table]))
  }

  # Create a metadata list with fields not generated by Seurat
  message("Preprocessing...")
  mito_pattern <- "^MT-"
  meta_list <- lapply(seq_along(data_list),function(index) {
    percent_mito <- 100 * Matrix::colSums(data_list[[index]][grep(mito_pattern, rownames(data_list[[index]])), ]) / Matrix::colSums(data_list[[index]])

    log2_transcript_counts <- log2(Matrix::colSums(data_list[[index]][-grep(mito_pattern, rownames(data_list[[index]])),]) + 1) # Excluding mito genes (will be removed)
    log2_feature_counts <- log2(Matrix::colSums(data_list[[index]][-grep(mito_pattern, rownames(data_list[[index]])),] > 0) + 1) # Excluding mito genes (will be removed)

    data.frame("percent_mito" = percent_mito,
               "log2_counts" = log2_transcript_counts,
               "log2_features" = log2_feature_counts,
               "condition" = rep(names(data_list)[[index]],ncol(data_list[[index]])))
  })

  # Match data_list and meta_list names
  names(meta_list) <- names(data_list)

  # Merge data and metadata
  message("Merging files...")
  data_merged <- lapply(data_list, as.data.frame) %>% dplyr::bind_cols()
  meta_merged <- meta_list %>% dplyr::bind_rows()

  # Remove mitochondrial genes and stressed cells
  data_merged <- data_merged[-grep(mito_pattern, rownames(data_merged)),]
  data_merged <- data_merged %>% dplyr::select(-PanethAnalysis::stressed_cells)

  # Create Seurat object and filter
  message("Creating Seurat object and filtering...")
  srat <- suppressWarnings(Seurat::CreateSeuratObject(data_merged, min.cells = 3, project = "IL22",
                                              meta.data = meta_merged))

  srat <- subset(srat, subset = nCount_RNA >= 3000 & nCount_RNA < 60000 & percent_mito < 25)

  return(srat)
}


#' Integrate data from IL22+ and IL22- conditions
#'
#' This function takes the output from \code{\link{preprocess_data}} and
#' performs data integration as described in
#' \href{https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8}{ Stuart,
#' Butler et al, 2019 }.
#'
#' @param data The output from \code{\link{preprocess_data}} which can
#'   be directly fed in using the pipe operator \code{\%>\%}
#'
#' @details Follows the steps documented in the Seurat vignette found
#'   \href{https://satijalab.org/seurat/articles/integration_introduction.html#performing-integration-on-datasets-normalized-with-sctransform-1}{here}.
#'   Briefly, \enumerate{ \item Calls \code{\link[Seurat]{SplitObject}} to
#'   subset the object by condition and outputs to a list \item Calls the
#'   function \code{\link[Seurat]{SCTransform}} to perform SCTransform
#'   normalization (described in \href{https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1}{Hafemeister and Satija, 2019}) on the split objects
#'   \item Calls \code{\link[Seurat]{SelectIntegrationFeatures}} to select integration features (n = 3000)
#'   \item Calls \code{\link[Seurat]{PrepSCTIntegration}} to run pre-integration checks
#'   \item Calls \code{\link[Seurat]{FindIntegrationAnchors}} to define integration anchors using the integration features selected above
#'   \item Calls \code{\link[Seurat]{IntegrateData}} to perform the data final data integration}
#'
#' @section Note: Should you receive the error below, you need to increase the
#'   size limit for global variables accessed by functions passed in the
#'   \code{future} package. This can be done by setting
#'   \code{options(future.globals.maxSize = 1000 * 1024^2)}, for example (1GB
#'   limit). Be aware that this will increase RAM usage, so use carefully. More
#'   information can be found
#'   \href{https://satijalab.org/seurat/articles/future_vignette.html}{here}.
#'
#'   \code{The total size of the X globals that need to be exported for the
#'   future expression ('FUN()') is X GiB. This exceeds the maximum allowed size
#'   of 500.00 MiB (option 'future.globals.maxSize'). The X largest globals are
#'   ... }
#'
#' @return An integrated Seurat object to be passed to \code{\link{process_data}}
#' @export
#' @family data processing
#'
#' @examples
#' \dontrun{
#' preprocess_data() %>% integrate_data()}
integrate_data <- function(data=NULL){

  # Split object by culture condition and normalize using SCTransform
  message("Applying SCT normalization...")
  srat.list <- Seurat::SplitObject(data, split.by = "condition")
  srat.list <- suppressWarnings(lapply(X = srat.list, FUN = Seurat::SCTransform, verbose=FALSE))

  # Select integration features and run integration pipeline
  message("Preparing for integration...")
  features <- suppressWarnings(Seurat::SelectIntegrationFeatures(object.list = srat.list, nfeatures = 3000, verbose = FALSE))
  srat.list <- suppressWarnings(Seurat::PrepSCTIntegration(object.list = srat.list, anchor.features = features, verbose = FALSE))

  srat.anchors <- suppressWarnings(Seurat::FindIntegrationAnchors(object.list = srat.list, normalization.method = "SCT",
                                         anchor.features = features, verbose = FALSE))
  message("Integrating data...")
  srat.combined.sct <- suppressWarnings(Seurat::IntegrateData(anchorset = srat.anchors, normalization.method = "SCT", verbose=FALSE))

  return(srat.combined.sct)
}

#' Process integrated data
#'
#' Runs dimensional reduction, graph-based clustering and cluster annotation
#'
#' @param data The output from \code{\link{integrate_data}} which can
#'   be directly fed in using the pipe operator \code{\%>\%}
#' @param output.dir Path to directory where DGE output should be saved
#'   (default is ".")
#'
#' @details This function runs the following data processing steps:
#' \enumerate{\item Performs PCA by calling \code{\link[Seurat]{RunPCA}}
#' \item Runs UMAP using the first 25 principal components (see \code{\link[Seurat]{RunUMAP}})
#' \item Performs graph-based clustering by calling \code{\link[Seurat]{FindNeighbors}} (using the first 25 principal components) and \code{\link[Seurat]{FindClusters}} (resolution of 0.8, Leiden algorithm)
#' \item Calls \code{\link[Seurat]{FindAllMarkers}} to perform differential gene expression analysis between the clusters defined in the previous step (only.pos = T, logfc.threshold = 0.5). Results are written in the directory specified by \code{output.dir} as "DE_perCluster.txt" (Supplemental Table 2)
#' \item Runs \code{\link[Seurat]{CellCycleScoring}} to infer cell cycle phase of each cell (relies on genes stored in \code{\link{cc_genes}})
#' \item Score cells for the Paneth cell marker gene module (DEFA5, DEFA6, PLA2G2A, PRSS2, REG3A and ITLN2)
#' \item Renames clusters according to manual annotations
#' \item Sub-clusters the Secretory progenitor cluster by calling \code{\link[Seurat]{FindSubCluster}} (resolution 1, Leiden algorithm)
#' \item Call Paneth cells (Paneth score > 1.5) and Tuft cells (sub-cluster 6)}
#'
#' @return An integrated Seurat object for which PCA and UMAP have been computed as well as (annotated) graph-based clustering
#' @export
#' @family data processing
#'
#' @examples
#' \dontrun{
#' preprocess_data() %>% integrate_data() %>% process_data()}
process_data <- function(data=NULL, output.dir = "."){

  # Run dimensional reduction (PCA then UMAP)
  umap_pcs <- 1:25
  message("Running PCA...")
  srat <- Seurat::RunPCA(data, verbose=F)
  message("Running UMAP...")
  srat <- suppressWarnings(RunUMAP(srat, reduction = "pca", dims = umap_pcs, verbose=F))

  # Run graph-based clustering
  message("Running graph-based clustering and DGE...")
  srat <- Seurat::FindNeighbors(srat, reduction = "pca", dims = umap_pcs, verbose=F)
  srat <- Seurat::FindClusters(srat, resolution = 0.8, graph.name = "integrated_snn",algorithm = 4)

  dge <- Seurat::FindAllMarkers(srat, only.pos = T, logfc.threshold = 0.5, verbose = F)

  Seurat::DefaultAssay(srat) <- "SCT"

  # Run Cell cycle scoring
  message("Running cell cycle inference...")
  srat <- Seurat::CellCycleScoring(object = srat, s.features = PanethAnalysis::cc_genes[1:43],
                           g2m.features = PanethAnalysis::cc_genes[44:97], set.ident = FALSE)

  message("Annotating clusters...")

  # Score Paneth cell module
  paneth.genes <- c("DEFA6","PLA2G2A","PRSS2","REG3A","ITLN2","defa5-ires2-dsred")
  paneth.score <- testModuleScore(Seurat::GetAssayData(srat),
                                  genes.list = list(paneth.genes), uniqueOnly = F, ctrl.size = 100)

  srat <- Seurat::AddMetaData(srat, paneth.score, col.name= "Paneth_score")

  # Rename clusters
  Seurat::Idents(srat) <- "integrated_snn_res.0.8"

  new.ids <- plyr::mapvalues(Idents(srat), from = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
                       to = c("Early EC", "EC", "EC", "TA2", "ISC", "Goblet", "TA1", "TA1", "Secretory progenitor", "TA1", "TA1", "EEC"))

  Seurat::Idents(srat) <- new.ids

  # Export DGE with final IDs appended
  dge <- cbind.data.frame(dge, cell_type = plyr::mapvalues(dge$cluster, from = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
                                                    to = c("Early EC", "EC", "EC", "TA2", "ISC", "Goblet",
                                                           "TA1", "TA1", "Secretory progenitor", "TA1", "TA1", "EEC")))
  rownames(dge) <- NULL
  write.table(dge, paste0(output.dir,"/DE_perCluster.txt"), quote = F, row.names = F)

  # Select tuft cells (AVIL expressing)
  srat <- Seurat::FindSubCluster(srat, cluster = "Secretory progenitor", resolution = 1, algorithm = 4, graph.name = "integrated_snn")
  Seurat::Idents(srat, cells = Seurat::WhichCells(srat, expression = sub.cluster == "Secretory progenitor_6")) <- "Tuft"

  # Select Paneth cells
  Seurat::Idents(srat, cells = Seurat::WhichCells(srat, expression = Paneth_score > 1.5)) <- "Paneth"

  srat <- Seurat::AddMetaData(srat, Idents(srat), "Final.IDS")

  return(srat)
}
